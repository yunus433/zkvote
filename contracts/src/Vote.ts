import {
  Field,
  SmartContract,
  state,
  State,
  method,
  DeployArgs,
  Permissions,
  Bool,
  Poseidon,
  PrivateKey,
  UInt64,
  PublicKey,
  MerkleWitness,
  MerkleTree,
  Reducer,
  Struct,
  CircuitValue,
  prop
} from 'snarkyjs';

 
const MAX_MERKLE_TREE_HEIGHT = 32;

export class MerkleWitnessClass extends MerkleWitness(MAX_MERKLE_TREE_HEIGHT) { }

export class IdentityCommitment extends Struct({
  identity: Field,
  public_nullifier: Field,
  isVoted: Bool
}) {
  constructor(identity: Field, public_nullifier: Field, isVoted: Bool) {
    super({ identity, public_nullifier, isVoted });
    this.identity = identity;
    this.public_nullifier = public_nullifier;
    this.isVoted = isVoted;
  }

  hash(): Field {
    return Poseidon.hash(this.identity.toFields().concat(this.public_nullifier.toFields()));
  }

  vote(): IdentityCommitment {
    return new IdentityCommitment(this.identity,this.public_nullifier, Bool(true));
  }
};

export class Voter extends Struct({
  key: PublicKey,
  isVoted: Bool
}) {
  constructor(key: PublicKey, isVoted: Bool) {
    super({ key, isVoted });
    this.key = key;
    this.isVoted = isVoted;
  }

  hash(): Field {
    return Poseidon.hash(this.key.toFields().concat(this.isVoted.toFields()));
  }

  vote(): Voter {
    return new Voter(this.key, Bool(true));
  }
};

export class Candidate extends CircuitValue {
  @prop key: Field; // Tree index
  @prop voteCount: Field;
  @prop witness: MerkleWitnessClass; // path

  constructor(key: Field, voteCount: Field, witness: MerkleWitnessClass) {
    super(
      key,
      voteCount,
      witness
    );
    this.key = key;
    this.voteCount = voteCount;
    this.witness = witness;
  }

  hash(): Field {
    return Poseidon.hash(this.key.toFields().concat(this.voteCount.toFields()));
  }

  addVote(): Candidate {
    return new Candidate(this.key, this.voteCount.add(1), this.witness);
  }
};


export class Vote extends SmartContract {
  @state(Bool) isFinished = State<Bool>(); // If tally function is yet called or not
  @state(UInt64) endTime = State<UInt64>(); // The end time of the election in UNIX Time
  @state(Field) candidateCount = State<Field>(); // How many candidates to vote for
  @state(Field) votersTree = State<Field>(); // Merkle root of voters
  @state(Field) commitmentsTree = State<Field>(); // Merkle root of voters
  @state(Field) candidatesTree = State<Field>(); // Merkle root of candidates
  @state(Field) candidatesTreeAccumulator = State<Field>(); // Merkle root of candidates as accumulator for the use of reducer

  reducer = Reducer({ actionType: Candidate });

  constructor(zkAppAddress: PublicKey) {
    super(zkAppAddress);
  }

  // Deploy smart contract, initialize base values
  deploy(args: DeployArgs) {
    super.deploy(args);
    this.setPermissions({
      ...Permissions.default(),
      editState: Permissions.proofOrSignature(),
      editSequenceState: Permissions.proofOrSignature(),
    });
    
    this.endTime.set(UInt64.from(0)); // Keeps from voters to vote before the start of election
    this.candidateCount.set(Field(0));
    this.isFinished.set(Bool(false));
    this.votersTree.set(Field(0));
    this.commitmentsTree.set(Field(0));
    this.candidatesTree.set(Field(0));
    this.candidatesTreeAccumulator.set(Reducer.initialActionsHash);
  };

  // Start the election with props. Can be called only once
  @method start(
    startTime: UInt64,
    endTime: UInt64,
    candidateCount: Field,
    votersTreeRoot: Field, // Merkle root, generated by offchain-storage.ts
    candidatesTreeRoot: Field // Merkle root, generated by offchain-storage.ts
  ) {
    const _endTime = this.endTime.get();
    this.endTime.assertEquals(_endTime);
    _endTime.assertEquals(UInt64.from(0)); // Check this is the first (and only) call for startElection
    
    const now = this.network.timestamp.get();
    this.network.timestamp.assertEquals(now);

    startTime.assertLt(endTime);
    endTime.assertGt(now);

    candidateCount.assertGt(Field(0));
    
    this.endTime.set(endTime);
    this.candidateCount.set(candidateCount);
    this.votersTree.set(votersTreeRoot);
    this.candidatesTree.set(candidatesTreeRoot);
  };

  @method commitIdentity(
    key: PrivateKey,
    nullifier: Field,
    voterPath: MerkleWitnessClass,
    commitmentPath: MerkleWitnessClass
  ): Field[] {

    let votersTree = this.votersTree.get(); // Get merkle root for voters from the state
    this.votersTree.assertEquals(votersTree);
    const voter = new Voter(key.toPublicKey(), Bool(false)); // Create a new voter with public key and is_voted: false
    voterPath.calculateRoot(voter.hash()).assertEquals(votersTree); // If already voted this voter will not be in the tree


    let identityCommitment: Field = Poseidon.hash(key.toFields().concat(nullifier)); // hash sum of public key and nullifier
    let publicNullifier: Field = Poseidon.hash(this.address.toFields().concat(nullifier));

    const newIdentityCommitment = new IdentityCommitment(identityCommitment,publicNullifier,Bool(false));
    const newCommitmentsTree = commitmentPath.calculateRoot(newIdentityCommitment.hash());
    this.commitmentsTree.assertEquals(this.commitmentsTree.get());
    this.commitmentsTree.set(newCommitmentsTree); 
    return [identityCommitment,publicNullifier]
     // store this in a new merkle tree
    // Only public keys included in merkle tree that is posted by election creator can create an identity commitmen
    // Inputs of this method is private and output is not predictable if tx is relayed.

  }
  // Vote for the election. Can be called only once for each voter. Single voting (one voter -> one candidate)
  @method vote(
    key: PrivateKey,
    nullifier: Field,
    candidate: Field,
    commitmentPath: MerkleWitnessClass,
    candidatePath: MerkleWitnessClass
  ): Field {
    // Election Conditions
    // Chech if tally is not called yet
    this.isFinished.assertEquals(Bool(false));
 
    // Voter Conditions
    let commitmentsTree = this.commitmentsTree.get(); // Get merkle root for voters from the state
    this.commitmentsTree.assertEquals(commitmentsTree);
    let VoterIdentityCommitment = Poseidon.hash(key.toFields().concat(nullifier))
    let PublicNullifier = Poseidon.hash(this.address.toFields().concat(nullifier));
    const identityCommitment = new IdentityCommitment(VoterIdentityCommitment,PublicNullifier, Bool(false)); // Create a new voter with public key and is_voted: false
    commitmentPath.calculateRoot(identityCommitment.hash()).assertEquals(commitmentsTree); // If already voted this voter will not be in the tree
    
    // Ballot Conditions
    const candidateCount = this.candidateCount.get();
    this.candidateCount.assertEquals(candidateCount);
    candidate.assertLt(Field(candidateCount));

    // Set merkle tree is_voted: true
    const newIdentityCommitment = identityCommitment.vote();
    const newCommitmentsTree = commitmentPath.calculateRoot(newIdentityCommitment.hash());
    this.commitmentsTree.set(newCommitmentsTree);

    // Dispatch the event as a new Candidate
    const newCandidate = new Candidate(candidate, Field(0), candidatePath); // Create a new candidate with given vote
    const candidatesTree = this.candidatesTree.get();
    this.candidatesTree.assertEquals(candidatesTree);
    candidatePath.calculateRoot(newCandidate.hash()).assertEquals(candidatesTree); // Check the path is correctly calculated for the candidate, so the vote is legal

    // Dispatch the event
    this.reducer.dispatch(newCandidate);

    return newCommitmentsTree;
  };

  // Tally the election. Count the votes in events and update candidateTree root. Returns an array representing the vote number for each candidate. Can be called only once
  @method tally(): UInt64[] {
    // Check tally is not yet called
    const isFinished = this.isFinished.get();
    this.isFinished.assertEquals(isFinished);
    isFinished.assertEquals(Bool(false));

    const candidatesCount = this.candidateCount.get();
    this.candidateCount.assertEquals(candidatesCount);
    const candidatesTree = this.candidatesTree.get();
    this.candidatesTree.assertEquals(candidatesTree);
    const candidatesTreeAccumulator = this.candidatesTreeAccumulator.get();
    this.candidatesTreeAccumulator.assertEquals(candidatesTreeAccumulator);

    // Create API request array [ voteCount ]
    const candidates = Array.from({ length: Number(candidatesCount) }, () => UInt64.from(0));

    const { state: newCandidatesTree, actionsHash: newCandidatesTreeAccumulator } = this.reducer.reduce(
      this.reducer.getActions({ fromActionHash: candidatesTreeAccumulator }),
      Field, // state type
      (state: Field, action: Candidate) => {
        // action => { key, voteCount: Field(0) }
        action = action.addVote(); // Action hash changed
        // Update API request object

        return action.witness.calculateRoot(action.hash());
      },
      { state: candidatesTree, actionsHash: candidatesTreeAccumulator }
    );

    // Offstorage API request
    this.candidatesTreeAccumulator.set(newCandidatesTreeAccumulator);
    this.candidatesTree.set(newCandidatesTree);
    this.isFinished.set(Bool(true));

    return candidates;
  };

  // Check if the given root for candidates matches the onchain value. To be used to show election results based on offchain values
  @method check(
    candidatesTree: Field
  ) {
    this.candidatesTree.assertEquals(candidatesTree);
  };
}


