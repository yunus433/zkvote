import {
  Field,
  SmartContract,
  state,
  State,
  method,
  DeployArgs,
  Permissions,
  Bool,
  Poseidon,
  PrivateKey,
  UInt64,
  PublicKey,
  MerkleWitness,
  Reducer,
  Struct,
  CircuitValue,
  prop,
  Circuit
} from 'snarkyjs';

const DEFAULT_PASSWORD = 0;
const MAX_CANDIDATE_COUNT = 1e3;
const MAX_MERKLE_TREE_HEIGHT = 32;

const STATUS = {
  DEPLOYED: 0, // Contract is deployed, voters are not yet set
  STARTED: 1, // Election is started, password for all voters is DEFAULT_PASSWORD
  SECURED: 2, // Voters set their password, voting process now is started
  FINISHED: 3 // Voter process is now complete, count function can be called
}

export class MerkleWitnessClass extends MerkleWitness(MAX_MERKLE_TREE_HEIGHT) { }

export class Voter extends Struct({
  key: PublicKey,
  password: Field,
  isVoted: Bool,
}) {
  constructor(key: PublicKey, password: Field, isVoted: Bool) {
    super({ key, password, isVoted });
    this.password = password;
    this.key = key;
    this.isVoted = isVoted;
  }

  hash(): Field {
    return Poseidon.hash(this.key.toFields().concat(this.password.toFields()).concat(this.isVoted.toFields()));
  }

  setPassword(
    password: Field
  ): Voter {
    return new Voter(this.key, password, this.isVoted);
  }

  vote(): Voter {
    return new Voter(this.key, this.password, Bool(true));
  }
};

export class Candidate extends CircuitValue {
  @prop key: Field; // Tree index
  @prop voteCount: Field;
  @prop witness: MerkleWitnessClass; // path

  constructor(key: Field, voteCount: Field, witness: MerkleWitnessClass) {
    super(
      key,
      voteCount,
      witness
    );
    this.key = key;
    this.voteCount = voteCount;
    this.witness = witness;
  }

  hash(): Field {
    return Poseidon.hash(this.key.toFields().concat(this.voteCount.toFields()));
  }

  addVote(): Candidate {
    return new Candidate(this.key, this.voteCount.add(1), this.witness);
  }
};

export class Vote extends SmartContract {
  @state(Field) status = State<Field>(); // Status of the election. Generated from STATUS object
  @state(Field) candidateCount = State<Field>(); // How many candidates to vote for
  @state(Field) secureVoterCount = State<Field>(); // How many candidates are ready to vote
  @state(Field) votersTree = State<Field>(); // Merkle root of voters
  @state(Field) candidatesTree = State<Field>(); // Merkle root of candidates
  @state(Field) candidatesTreeAccumulator = State<Field>(); // Merkle root of candidates as accumulator for the use of reducer

  reducer = Reducer({ actionType: Candidate });

  constructor(zkAppAddress: PublicKey) {
    super(zkAppAddress);
  }

  // Deploy smart contract, initialize base values
  deploy(args: DeployArgs) {
    super.deploy(args);
    this.setPermissions({
      ...Permissions.default(),
      editState: Permissions.proofOrSignature(),
      editSequenceState: Permissions.proofOrSignature(),
    });
    
    this.candidateCount.set(Field(0));
    this.secureVoterCount.set(Field(0));
    this.status.set(Field(STATUS.DEPLOYED));
    this.votersTree.set(Field(0));
    this.candidatesTree.set(Field(0));
    this.candidatesTreeAccumulator.set(Reducer.initialActionsHash);
  };

  // Start the election with props. Can be called only once
  @method start(
    candidateCount: Field,
    votersTreeRoot: Field, // Merkle root, generated by offchain-storage.ts
    candidatesTreeRoot: Field // Merkle root, generated by offchain-storage.ts
  ) {
    this.status.assertEquals(Field(STATUS.DEPLOYED));

    candidateCount.assertGt(Field(0));
    
    this.candidateCount.set(candidateCount);
    this.votersTree.set(votersTreeRoot);
    this.candidatesTree.set(candidatesTreeRoot);
    this.status.set(Field(STATUS.STARTED));
  };

  // Set the vote of a voter. Can be called only once
  @method setPassword(
    key: PrivateKey, // Private Key of the voter to set the password
    password: Field, // Field chosen by the voter as password
    path: MerkleWitnessClass
  ) {
    this.status.assertEquals(Field(STATUS.STARTED));

    password.assertGt(Field(0));

    let votersTree = this.votersTree.get();
    this.votersTree.assertEquals(votersTree);
    const voter = new Voter(key.toPublicKey(), Field(DEFAULT_PASSWORD), Bool(false));
    path.calculateRoot(voter.hash()).assertEquals(votersTree);

    const newVoter = voter.setPassword(password);
    const newVotersTree = path.calculateRoot(newVoter.hash());
    this.votersTree.set(newVotersTree);
    this.secureVoterCount.assertEquals(this.secureVoterCount.get());
    this.secureVoterCount.set(this.secureVoterCount.get().add(Field(1)));
  };

  // Start the vote. No password can be set after this point
  @method startVote() {
    this.status.assertEquals(Field(STATUS.STARTED));

    const secureVoterCount = this.secureVoterCount.get();
    this.secureVoterCount.assertEquals(secureVoterCount);
    secureVoterCount.assertGt(Field(0)); // At least 1 voter to vote

    this.status.set(Field(STATUS.SECURED));
  }

  // Vote for the election. Can be called only once for each voter. Single voting (one voter -> one candidate)
  @method vote(
    key: PrivateKey,
    password: Field,
    candidate: Field,
    voterPath: MerkleWitnessClass,
    candidatePath: MerkleWitnessClass
  ): Field {
    // Election Conditions
    this.status.assertEquals(Field(STATUS.SECURED));

    // Voters with the DEFAULT_PASSWORD cannot vote
    password.assertGt(Field(DEFAULT_PASSWORD));

    // Voter Conditions
    let votersTree = this.votersTree.get(); // Get merkle root for voters from the state
    this.votersTree.assertEquals(votersTree);
    const voter = new Voter(key.toPublicKey(), Field(password), Bool(false)); // Create a new voter with public key and is_voted: false
    voterPath.calculateRoot(voter.hash()).assertEquals(votersTree); // If already voted this voter will not be in the tree

    // Ballot Conditions
    const candidateCount = this.candidateCount.get();
    this.candidateCount.assertEquals(candidateCount);
    candidate.assertLt(Field(candidateCount));

    // Set merkle tree is_voted: true
    const newVoter = voter.vote();
    const newVotersTree = voterPath.calculateRoot(newVoter.hash());
    this.votersTree.set(newVotersTree);

    // Dispatch the event as a new Candidate
    const newCandidate = new Candidate(candidate, Field(0), candidatePath); // Create a new candidate with given vote
    const candidatesTree = this.candidatesTree.get();
    this.candidatesTree.assertEquals(candidatesTree);
    candidatePath.calculateRoot(newCandidate.hash()).assertEquals(candidatesTree); // Check the path is correctly calculated for the candidate, so the vote is legal

    // Dispatch the event
    this.reducer.dispatch(newCandidate);

    return newVotersTree;
  };

  // Tally the election. Count the votes in events and update candidateTree root. Returns an array representing the vote number for each candidate. Can be called only once
  @method tally() {
    // Check tally is not yet called
    this.status.assertEquals(Field(STATUS.SECURED));

    const candidatesCount = this.candidateCount.get();
    this.candidateCount.assertEquals(candidatesCount);
    const candidatesTree = this.candidatesTree.get();
    this.candidatesTree.assertEquals(candidatesTree);
    const candidatesTreeAccumulator = this.candidatesTreeAccumulator.get();
    this.candidatesTreeAccumulator.assertEquals(candidatesTreeAccumulator);

    const { state: newCandidatesTree, actionsHash: newCandidatesTreeAccumulator } = this.reducer.reduce(
      this.reducer.getActions({ fromActionHash: candidatesTreeAccumulator }),
      Field, // state type
      (state: Field, action: Candidate) => {
        action = action.addVote(); // Action hash changed

        return action.witness.calculateRoot(action.hash());
      },
      { state: candidatesTree, actionsHash: candidatesTreeAccumulator }
    );

    // this.candidatesTreeAccumulator.set(newCandidatesTreeAccumulator); !!! IMPORTANT !!! Do not update accumulator for count function.
    this.candidatesTree.set(newCandidatesTree);
    this.status.set(Field(STATUS.FINISHED));
  };

  // Count number of votes for only one candidate. TODO Count all the candidates at the same time and return array
  @method count(
    key: Field
  ): Field {
    this.status.assertEquals(Field(STATUS.FINISHED));

    const candidatesCount = this.candidateCount.get();
    this.candidateCount.assertEquals(candidatesCount);
    const candidatesTree = this.candidatesTree.get();
    this.candidatesTree.assertEquals(candidatesTree);
    const candidatesTreeAccumulator = this.candidatesTreeAccumulator.get();
    this.candidatesTreeAccumulator.assertEquals(candidatesTreeAccumulator);

    const { state: voteCount, actionsHash: newCandidatesTreeAccumulator } = this.reducer.reduce(
      this.reducer.getActions({ fromActionHash: candidatesTreeAccumulator }),
      Field, // state type
      (state: Field, action: Candidate) => {
        action = action.addVote(); // Action hash changed
        return state.add(Circuit.if(action.key.equals(key), Field(1), Field(0)));
      },
      { state: Field(0), actionsHash: candidatesTreeAccumulator }
    );

    return voteCount;
  };

  // Check if the given root for candidates matches the onchain value. To be used to show election results based on offchain values
  @method check(
    candidatesTree: Field
  ) {
    this.candidatesTree.assertEquals(candidatesTree);
  };
}
